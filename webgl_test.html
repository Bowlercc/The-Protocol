<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Procedural Ridges (WebGL)</title>
  <style>
    html, body { margin: 0; height: 100%; background:#fff; overflow: hidden; }
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

const renderer = new THREE.WebGLRenderer({ antialias: true });
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

const uniforms = {
  u_time: { value: 0 },
  u_res:  { value: new THREE.Vector2(1, 1) },
  u_mouse:{ value: new THREE.Vector2(-10, -10) },
  u_down: { value: 0.0 },
  u_seed: { value: Math.random() * 1000.0 },
};

const vert = /* glsl */`
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`;

const frag = /* glsl */`
  precision highp float;
  varying vec2 vUv;

  uniform float u_time;
  uniform vec2  u_res;
  uniform vec2  u_mouse;
  uniform float u_down;
  uniform float u_seed;

  // ---- hashes / noise (no textures) ----
  float hash21(vec2 p) {
    p += u_seed;
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
  }

  vec2 hash22(vec2 p) {
    p += u_seed;
    vec2 q = vec2(
      dot(p, vec2(127.1, 311.7)),
      dot(p, vec2(269.5, 183.3))
    );
    return fract(sin(q) * 43758.5453123);
  }

  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f*f*(3.0 - 2.0*f);
    float a = hash21(i + vec2(0,0));
    float b = hash21(i + vec2(1,0));
    float c = hash21(i + vec2(0,1));
    float d = hash21(i + vec2(1,1));
    return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
  }

  float fbm(vec2 p) {
    float v = 0.0;
    float a = 0.5;
    for (int i = 0; i < 5; i++) {
      v += a * noise(p);
      p *= 2.0;
      a *= 0.5;
    }
    return v;
  }

  // ---- find 2 nearest "feature points" (Voronoi-ish) ----
  void voronoi2(in vec2 x, out vec2 p1, out float d1, out vec2 p2, out float d2) {
    vec2 n = floor(x);
    vec2 f = fract(x);

    d1 = 1e9; d2 = 1e9;
    p1 = vec2(0.0); p2 = vec2(0.0);

    for (int j = -1; j <= 1; j++) {
      for (int i = -1; i <= 1; i++) {
        vec2 g = vec2(float(i), float(j));
        vec2 cell = n + g;

        // animated jitter per cell (subtle)
        vec2 o = hash22(cell);
        float t = u_time * 0.15;
        o += 0.15 * vec2(
          sin(t + 6.2831*o.x),
          cos(t + 6.2831*o.y)
        );

        vec2 fp = cell + o;       // feature point in cell-space
        vec2 r = (g + o) - f;
        float d = dot(r, r);

        if (d < d1) {
          d2 = d1; p2 = p1;
          d1 = d;  p1 = fp;
        } else if (d < d2) {
          d2 = d;  p2 = fp;
        }
      }
    }
  }

  void main() {
    // aspect-correct coordinate in "world" space
    vec2 fragCoord = vUv * u_res;
    float s = min(u_res.x, u_res.y);
    vec2 p = (fragCoord * 2.0 - u_res) / s;

    // mouse in same space
    vec2 m = (u_mouse * 2.0 - u_res) / s;

    // interactive “stir” around mouse (stronger on click)
    float md = length(p - m);
    float stir = (0.18 + 0.45 * u_down) * exp(-md * 2.0);
    vec2  pm  = p - m;
    p += stir * vec2(-pm.y, pm.x);

    // domain warp for organic variation
    float t = u_time;
    vec2 warp = vec2(
      fbm(p*2.0 + vec2(0.0, t*0.15)),
      fbm(p*2.0 + vec2(5.2, -t*0.12))
    );
    p += 0.25 * (warp - 0.5);

    // cell-space scaling controls “blob size”
    float CELL = 3.6;
    vec2 x = p * CELL;

    // find 2 nearest vortex centres in cell-space
    vec2 c1, c2;
    float d1, d2;
    voronoi2(x, c1, d1, c2, d2);

    // local polar around each centre (in cell-space)
    vec2 v1 = x - c1;
    vec2 v2 = x - c2;
    float r1 = length(v1);
    float r2 = length(v2);
    float a1 = atan(v1.y, v1.x);
    float a2 = atan(v2.y, v2.x);

    // phase fields (distance + angle => spirals)
    // tweak these to change “fingerprint-ness”
    float radial  = 2.2;
    float angular = 1.6;

    float u1 = r1 * radial + a1 * angular;
    float u2 = r2 * radial + a2 * angular;

    // blend near Voronoi borders to avoid hard seams
    float diff = sqrt(d2) - sqrt(d1);        // small near borders
    float k = smoothstep(0.03, 0.28, diff);  // 0 = border, 1 = inside cell
    float u = mix(u2, u1, k);

    // subtle global drift & extra “ridge meander”
    u += 0.55 * (fbm(x*0.55 + t*0.1) - 0.5);

    // turn phase into contour lines
    float freq = 6.5;        // line density
    float phase = u * freq;

    float g = abs(fract(phase) - 0.5);       // 0 at line centres
    float aa = fwidth(phase) * 0.9;
    float lineWidth = 0.085;

    float ridge = 1.0 - smoothstep(lineWidth, lineWidth + aa, g);

    // small thickness variation
    ridge *= 0.85 + 0.15 * noise(x*0.4);

    // colour
    vec3 bg   = vec3(0.97);
    vec3 ink  = vec3(0.12);
    vec3 col  = mix(bg, ink, ridge);

    gl_FragColor = vec4(col, 1.0);
  }
`;

const mat = new THREE.ShaderMaterial({ uniforms, vertexShader: vert, fragmentShader: frag });
const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);
scene.add(mesh);

function resize() {
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const w = Math.floor(innerWidth * dpr);
  const h = Math.floor(innerHeight * dpr);
  renderer.setSize(w, h, false);
  uniforms.u_res.value.set(w, h);
}
window.addEventListener("resize", resize);
resize();

let down = false;
window.addEventListener("pointermove", (e) => {
  const rect = renderer.domElement.getBoundingClientRect();
  uniforms.u_mouse.value.set(
    (e.clientX - rect.left) * (renderer.domElement.width / rect.width),
    (rect.height - (e.clientY - rect.top)) * (renderer.domElement.height / rect.height)
  );
});
window.addEventListener("pointerdown", () => { down = true; uniforms.u_down.value = 1.0; });
window.addEventListener("pointerup",   () => { down = false; uniforms.u_down.value = 0.0; });

const clock = new THREE.Clock();
function tick() {
  uniforms.u_time.value += clock.getDelta();
  // optional: ease mouse-down for smoother feel
  uniforms.u_down.value += (down ? 1.0 : 0.0 - uniforms.u_down.value) * 0.15;

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
tick();
</script>
</body>
</html>
